import csv
import json
import gzip
import sys
from seq_utils import SC2Locator
import re


def get_mutations(counts, lineages, inner_tol=0.95, outer_tol=0.05, complete=True,
                  min_count=20):
    """
    Generate a list of mutations that are present at some minimum frequency
    in every member of a user-specified subset of lineages.

    :param counts:  dict, mutation frequencies by lineage, e.g.,
                    {"B": {"mutations": {"~|11082|T": 3, ...}, "count": 10}, ...
    :param lineages:  list, focal lineages to extract high-frequency mutations
    :param inner_tol:  float, minimum frequency within lineage for a mutation to
                   be considered lineage-specific (default 0.95).
    :param outer_tol:  float, maximum tolerated frequency of mutation in lineage
                   outside of specified set (default 0.05).
    :param complete:  if True, inner tolerance must be met by all focal lineages
    :param min_count:  int, minimum count to screen background lineage
    :return:  list, lineage-specific mutations
    """
    # find lineage consensus mutations
    mutations = {}
    for lineage in lineages:
        if lineage not in counts:
            sys.stderr.write("WARNING: lineage {} is not in counts dict".format(lineage))
            continue
        denom = counts[lineage]['count']
        for m, n in counts[lineage]["mutations"].items():
            freq = n / denom
            if freq > inner_tol:
                if m not in mutations:
                    mutations.update({m: 0})
                mutations[m] += 1

    if complete:
        # exceeds inner threshold for every focal lineage
        consensus = [m for m, nl in mutations.items() if nl == len(lineages)]
    else:
        # exceeds inner threshold in at least one focal lineage
        consensus = [m for m, nl in mutations.items() if nl > 0]

    # screen mutations for frequency in background
    specific = []
    for mutation in consensus:
        reject = False
        for lineage, ldata in counts.items():
            if lineage in lineages or lineage is None:
                continue
            if ldata['count'] < min_count or mutation not in ldata['mutations']:
                continue
            freq = ldata['mutations'][mutation] / ldata['count']
            if freq > outer_tol:
                reject = True
                break

        if not reject:
            # threshold met in all background lineages
            specific.append(mutation)

    return specific


if __name__ == "__main__":
    # command line interface
    import argparse
    parser = argparse.ArgumentParser(description='Generate a list (CSV) of lineage-specific mutations.')
    parser.add_argument('json', type=str, default="data/count-mutations_nsgb.json.gz",
                        help="input, JSON containing mutation counts per PANGO lineage; "
                             "e.g., generated by retrieve-nsgb.py.")
    parser.add_argument('lineage', type=str,
                        help="A single PANGO lineage designation (e.g., \"BA.1\"), or a quoted regular "
                             "expression for specifying a set of lineages, e.g., \"B\\.1\\.617\\.2|\"|AY\\.")
    parser.add_argument('--inner', '-i', type=float, default=0.95,
                        help="float, minimum frequency for mutations within lineage(s), default 0.95")
    parser.add_argument('--outer', '-o', type=float, default=0.05,
                        help="float, maximum tolerated frequency for mutations in background, default 0.05")
    parser.add_argument('--single', action="store_true",
                        help="if set, inner threshold does not have to be met for every lineage")
    parser.add_argument('--mincount', type=int, default=20,
                        help="int, minimum number of genomes per background lineage (default 20)")
    parser.add_argument('--reffile', type=str, default="data/NC_045512.fa",
                        help="str, path to FASTA containing SARS-CoV-2 reference genome")
    args = parser.parse_args()

    # read in JSON of mutations in all lineages
    if args.json.endswith('.gz'):
        # TODO: check magic number
        counts = json.load(gzip.open(args.json, 'rt'))
    else:
        counts = json.load(open(args.json))

    # parse lineage regex
    pat = re.compile(args.lineage)
    lineages = [lineage for lineage in counts.keys() if pat.fullmatch(lineage)]
    if len(lineages) == 0:
        sys.stderr.write("ERROR: failed to match lineage regex {} to any member of counts "
                         "dict".format(args.lineage))
        sys.exit()

    mutations = get_mutations(
        counts=counts, lineages=lineages,
        inner_tol=args.inner, outer_tol=args.outer,
        complete=not args.single, min_count=args.mincount
    )

    # write CSV to stdout (user can redirect to file)
    writer = csv.writer(sys.stdout)
    writer.writerow(["type", "pos", "alt", "label"])  # write header
    locator = SC2Locator()  # maps mutations to reference to generate labels, e.g., aa sub
    for mutation in mutations:
        typ, pos, alt = mutation.split('|')  # parse CoVizu notation
        label = locator.parse_mutation([typ, int(pos), alt])
        writer.writerow([typ, int(pos)+1, alt, label])
